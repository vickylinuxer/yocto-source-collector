# yocto-source-collector

Tools for collecting, verifying, and compile-testing the source files that were
actually compiled into a Yocto image's installed binaries.

## Scripts

| Script | Purpose |
|--------|---------|
| `yocto_source_utils.py` | Shared library: package discovery, DWARF extraction, kernel helpers |
| `collect_sources.py` | Collect `.c`/`.h`/`.S` sources per installed package |
| `verify_sources.py` | Verify collected sources against installed ELF DWARF info |
| `test_sources.py` | Parse compiler logs and optionally re-compile using collected sources |

## How it works

### Collection (`collect_sources.py`)

For **userspace packages**: reads `debugsources.list` (generated by Yocto from
DWARF debug info during packaging) to identify every source file compiled into
the package's binaries.  Only files belonging to the package's own recipe are
collected (shared-library sources from other recipes are filtered out).

For the **kernel image**: finds all `.o` files in the kernel build directory that
are not owned by any kernel module, then copies the corresponding `.c`/`.S` from
`kernel-source/`.

For **kernel modules**: uses `.mod` files to enumerate the object files, then
collects the corresponding sources from `kernel-source/`.

Packages with no compiled source (scripts, configs, data) get a
`NO_COMPILED_SOURCE.txt` marker.

### Verification (`verify_sources.py`)

Re-reads DWARF CU source paths from the installed `.debug` binaries and checks
that every referenced source file exists in the collected directory.

### Compile test (`test_sources.py`)

Parses `temp/log.do_compile` to extract every `gcc -c` invocation, then:

1. **Coverage check**: reports which compiled sources are (and aren't) in the
   collected directory.
2. **Compile test** (`--compile`): re-runs each compile command with the
   collected source replacing the original and verifies it succeeds.

## Usage

```bash
# Source the Yocto build environment first (or pass paths explicitly)

# Collect sources
python3 collect_sources.py -b $BUILDDIR -m core-image-minimal -o ./sources

# Verify collected sources against DWARF
python3 verify_sources.py -b $BUILDDIR -m core-image-minimal -s ./sources

# Check coverage (which compiled sources are collected)
python3 test_sources.py -b $BUILDDIR -m core-image-minimal -s ./sources

# Re-compile using collected sources and verify success
python3 test_sources.py -b $BUILDDIR -m core-image-minimal -s ./sources --compile

# Test specific packages only
python3 test_sources.py -b $BUILDDIR -m core-image-minimal -s ./sources \
    --compile -p busybox,dropbear
```

## Common arguments

| Flag | Description |
|------|-------------|
| `-b / --build` | Yocto build directory (`$BUILDDIR`) |
| `-m / --manifest` | Image name (e.g. `core-image-minimal`) or path to `.manifest` file |
| `-s / --sources` | Collected sources directory (default: `<build-dir>/sources`) |
| `-v / --verbose` | Verbose output |

## Requirements

- Python 3.10+
- `readelf` (from binutils) — for DWARF extraction in `verify_sources.py`
- `objcopy` (from binutils) — for `.o` comparison in `test_sources.py`
- Cross-compiler toolchain must be present (Yocto sysroot in build dir)

## Notes

- `.o` files always differ in the compile test because `-fdebug-prefix-map` and
  `-fmacro-prefix-map` embed the source path in DWARF/macro sections.  This is
  expected and reported separately as "mismatch", not as a failure.
- "INCOMPLETE" status means some compile commands target uninstalled binaries or
  disabled optional features — the uncollected files are correct omissions.
